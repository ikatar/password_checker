<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PassGuard</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.73.0/build/stlite.css"
    />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.73.0/build/stlite.js"></script>
    <script>
      stlite.mount(
        {
          requirements: ["pyodide-http"],
          entrypoint: "app.py",
          files: {
            "app.py": "import hashlib\nimport math\nimport re\nimport secrets\nimport string\n\ntry:\n    import pyodide_http\n    pyodide_http.patch_all()\nexcept ImportError:\n    pass\n\nimport requests\nimport streamlit as st\n\n# \u2500\u2500 Breach checking (HIBP k-anonymity) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef check_breach(password: str) -> int:\n    \"\"\"Return the number of times *password* appears in known data breaches.\n\n    Only the first 5 characters of the SHA-1 hash are sent over the network\n    (k-anonymity).  The full hash never leaves the client.\n    \"\"\"\n    sha1 = hashlib.sha1(password.encode(\"utf-8\")).hexdigest().upper()\n    prefix, suffix = sha1[:5], sha1[5:]\n\n    resp = requests.get(\n        f\"https://api.pwnedpasswords.com/range/{prefix}\",\n        timeout=10,\n    )\n    resp.raise_for_status()\n\n    for line in resp.text.splitlines():\n        hash_suffix, count = line.split(\":\")\n        if hash_suffix == suffix:\n            return int(count)\n    return 0\n\n\n# \u2500\u2500 Strength analysis \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n_SEQUENCES = [\n    \"abcdefghijklmnopqrstuvwxyz\",\n    \"0123456789\",\n    \"qwertyuiop\",\n    \"asdfghjkl\",\n    \"zxcvbnm\",\n]\n\n\ndef score_strength(password: str) -> dict:\n    \"\"\"Analyse password strength and return a detailed report.\n\n    Returns a dict with keys:\n        length       -- int\n        entropy      -- float (bits)\n        char_classes -- dict[str, bool]  (lowercase, uppercase, digits, symbols)\n        score        -- int 0-4  (0 = very weak ... 4 = very strong)\n        label        -- str\n        warnings     -- list[str]\n    \"\"\"\n    warnings: list[str] = []\n\n    # Character-class analysis\n    classes = {\n        \"lowercase\": bool(re.search(r\"[a-z]\", password)),\n        \"uppercase\": bool(re.search(r\"[A-Z]\", password)),\n        \"digits\":    bool(re.search(r\"\\d\", password)),\n        \"symbols\":   bool(re.search(r\"[^a-zA-Z\\d]\", password)),\n    }\n\n    pool = sum([\n        26 if classes[\"lowercase\"] else 0,\n        26 if classes[\"uppercase\"] else 0,\n        10 if classes[\"digits\"] else 0,\n        32 if classes[\"symbols\"] else 0,\n    ]) or 1\n\n    entropy = len(password) * math.log2(pool) if password else 0.0\n\n    # Pattern detection\n    lower = password.lower()\n    for seq in _SEQUENCES:\n        for i in range(len(seq) - 2):\n            chunk = seq[i : i + 3]\n            if chunk in lower or chunk[::-1] in lower:\n                warnings.append(f\"Sequential pattern detected ('{chunk}')\")\n                break\n\n    if re.search(r\"(.)\\1{2,}\", password):\n        warnings.append(\"Repeated characters detected (e.g. 'aaa')\")\n\n    if len(password) < 8:\n        warnings.append(\"Too short -- use at least 8 characters\")\n    elif len(password) < 12:\n        warnings.append(\"Consider using 12+ characters\")\n\n    # Deduplicate while preserving order\n    warnings = list(dict.fromkeys(warnings))\n\n    # Composite score\n    class_count = sum(classes.values())\n    if entropy < 28 or len(password) < 8:\n        score = 0\n    elif entropy < 36 or class_count < 2:\n        score = 1\n    elif entropy < 50 or class_count < 3:\n        score = 2\n    elif entropy < 65:\n        score = 3\n    else:\n        score = 4\n\n    labels = [\"Very Weak\", \"Weak\", \"Fair\", \"Strong\", \"Very Strong\"]\n\n    return {\n        \"length\": len(password),\n        \"entropy\": round(entropy, 1),\n        \"char_classes\": classes,\n        \"score\": score,\n        \"label\": labels[score],\n        \"warnings\": warnings,\n    }\n\n\n# \u2500\u2500 Password generation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef generate_password(\n    length: int = 16,\n    *,\n    uppercase: bool = True,\n    digits: bool = True,\n    symbols: bool = True,\n) -> str:\n    \"\"\"Generate a cryptographically secure random password.\n\n    Guarantees at least one character from each enabled character class.\n    Uses :mod:`secrets` for cryptographic randomness.\n    \"\"\"\n    if length < 4:\n        raise ValueError(\"Password length must be at least 4\")\n\n    alphabet = string.ascii_lowercase\n    required = [secrets.choice(string.ascii_lowercase)]\n\n    if uppercase:\n        alphabet += string.ascii_uppercase\n        required.append(secrets.choice(string.ascii_uppercase))\n    if digits:\n        alphabet += string.digits\n        required.append(secrets.choice(string.digits))\n    if symbols:\n        alphabet += string.punctuation\n        required.append(secrets.choice(string.punctuation))\n\n    remaining = length - len(required)\n    chars = required + [secrets.choice(alphabet) for _ in range(remaining)]\n\n    # Fisher-Yates shuffle with cryptographic randomness\n    for i in range(len(chars) - 1, 0, -1):\n        j = secrets.randbelow(i + 1)\n        chars[i], chars[j] = chars[j], chars[i]\n\n    return \"\".join(chars)\n\nst.set_page_config(page_title=\"PassGuard\", page_icon=\"\\U0001f6e1\\ufe0f\", layout=\"centered\")\n\nst.title(\"\\U0001f6e1\\ufe0f PassGuard\")\nst.caption(\n    \"Check password security and generate strong passwords.  \\n\"\n    \"Your password is **never** sent over the network \\u2014 \"\n    \"only the first 5 characters of its SHA-1 hash are transmitted \"\n    \"([k-anonymity](https://en.wikipedia.org/wiki/K-anonymity)).\"\n)\n\ntab_check, tab_generate = st.tabs([\"\\U0001f50d Check Password\", \"\\U0001f511 Generate Password\"])\n\n# \u2500\u2500 Check tab \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nwith tab_check:\n    password = st.text_input(\n        \"Password\", type=\"password\", placeholder=\"Enter a password\\u2026\",\n    )\n\n    if password:\n        report = score_strength(password)\n\n        colors = [\"#d32f2f\", \"#f57c00\", \"#fbc02d\", \"#388e3c\", \"#1b5e20\"]\n        color = colors[report[\"score\"]]\n        st.markdown(\n            f\"**Strength:** <span style='color:{color}'>{report['label']}</span>\"\n            f\" &nbsp;\\u00b7&nbsp; {report['entropy']} bits of entropy\",\n            unsafe_allow_html=True,\n        )\n        st.progress((report[\"score\"] + 1) / 5)\n\n        for w in report[\"warnings\"]:\n            st.warning(w, icon=\"\\u26a0\\ufe0f\")\n\n        if st.button(\"Check breach database\", type=\"primary\"):\n            with st.spinner(\"Querying Have I Been Pwned\\u2026\"):\n                try:\n                    count = check_breach(password)\n                except Exception as exc:\n                    st.error(f\"**Connection error:** {exc}\")\n                    st.stop()\n\n            if count:\n                st.error(\n                    f\"**Breached!** This password appeared in **{count:,}** \"\n                    f\"data breach{'es' if count != 1 else ''}. \"\n                    \"Change it immediately.\"\n                )\n            else:\n                st.success(\n                    \"**Safe!** Not found in any known data breaches.\"\n                )\n\n# \u2500\u2500 Generate tab \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nwith tab_generate:\n    col1, col2 = st.columns(2)\n    with col1:\n        length = st.slider(\"Length\", 8, 64, 16)\n    with col2:\n        use_upper = st.checkbox(\"Uppercase\", value=True)\n        use_digits = st.checkbox(\"Digits\", value=True)\n        use_symbols = st.checkbox(\"Symbols\", value=True)\n\n    if st.button(\"Generate password\", type=\"primary\"):\n        pwd = generate_password(\n            length, uppercase=use_upper, digits=use_digits, symbols=use_symbols,\n        )\n        report = score_strength(pwd)\n        st.code(pwd, language=None)\n        color = [\"#d32f2f\", \"#f57c00\", \"#fbc02d\", \"#388e3c\", \"#1b5e20\"][report[\"score\"]]\n        st.markdown(\n            f\"<span style='color:{color}'>{report['label']}</span>\"\n            f\" &nbsp;\\u00b7&nbsp; {report['entropy']} bits of entropy\",\n            unsafe_allow_html=True,\n        )\n",
          },
        },
        document.getElementById("root")
      );
    </script>
  </body>
</html>
